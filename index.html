<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>çº¯æœ¬åœ°é“¾æ¸¸ - æ•°æ®ä¸å¯ç¯¡æ”¹</title>
<style>
*{box-sizing:border-box;margin:0;padding:0;font-family:system-ui}
body{background:#0b0f1a;color:#fff;padding:20px}
.container{max-width:600px;margin:0 auto}
.log{background:#121a29;padding:12px;border-radius:8px;margin:10px 0;min-height:120px;font-size:13px;white-space:pre-wrap}
.btn{padding:8px 12px;margin:4px;border:none;border-radius:6px;background:#4a7dff;color:#fff;cursor:pointer}
.btn-success{background:#00C851}
.btn-warning{background:#ff8800}
input{width:100%;padding:10px;margin:8px 0;border-radius:6px;border:none;background:#1e2530;color:#fff}
</style>
</head>
<body>
<div class="container">
  <h1>çº¯æœ¬åœ°é“¾æ¸¸ Â· æ•°æ®ä¸å¯ç¯¡æ”¹</h1>
  <p>æ¶æ„ï¼šæœ¬åœ°å“ˆå¸Œé“¾ + åŠ©è®°è¯ + æœ¬åœ°å­˜æ¡£</p>

  <button class="btn" onclick="createWallet()">ç”Ÿæˆé’±åŒ…</button>
  <button class="btn" onclick="showMnemonic()">æŸ¥çœ‹åŠ©è®°è¯</button>
  <button class="btn-success" onclick="mintItem()">ç”Ÿæˆæ–°æ‰‹å‰‘</button>
  <button class="btn" onclick="showItems()">æŸ¥çœ‹æˆ‘çš„é“å…·</button>
  <button class="btn btn-warning" onclick="verifyChainBtn()">æ ¡éªŒé“¾æ˜¯å¦ç¯¡æ”¹</button>

  <button class="btn" onclick="exportArchive()">å¯¼å‡ºå­˜æ¡£</button>
  <button class="btn" onclick="importArchive()">å¯¼å…¥å­˜æ¡£</button>

  <h3>æ—¥å¿—</h3>
  <div id="log" class="log">ç­‰å¾…æ“ä½œâ€¦</div>
</div>

<script>
const logDom = document.getElementById('log');
const KEY_MNEMONIC = 'game_mnemonic';
const KEY_CHAIN = 'game_chain';

const words = "apple banana cherry date elder fig grape honey ice juice kite lemon mango nut orange pear queen rose sun tomato umbrella van water xmas yellow zebra".split(' ');

function log(text) {
  logDom.innerText = `[${new Date().toLocaleString()}] ${text}\n` + logDom.innerText;
}

// ====================== é’±åŒ… ======================
function createWallet() {
  const mnemonic = Array(12).fill(0).map(() => words[Math.random()*words.length|0]).join(' ');
  localStorage.setItem(KEY_MNEMONIC, mnemonic);
  log('âœ… é’±åŒ…å·²ç”Ÿæˆ');
}

function showMnemonic() {
  const mne = localStorage.getItem(KEY_MNEMONIC);
  mne ? log('ğŸ“„ åŠ©è®°è¯ï¼š' + mne) : log('âš ï¸ æœªåˆ›å»ºé’±åŒ…');
}

// ====================== SHA256 å“ˆå¸Œ ======================
async function sha256(s) {
  const enc = new TextEncoder();
  const d = await crypto.subtle.digest('SHA-256', enc.encode(s));
  return Array.from(new Uint8Array(d)).map(b => b.toString(16).padStart(2,'0')).join('');
}

// ====================== æœ¬åœ°ä¸å¯ç¯¡æ”¹å“ˆå¸Œé“¾ ======================
function initChain() {
  if (!localStorage.getItem(KEY_CHAIN)) {
    localStorage.setItem(KEY_CHAIN, '[]');
  }
}

function getChain() {
  return JSON.parse(localStorage.getItem(KEY_CHAIN) || '[]');
}

function saveChain(chain) {
  localStorage.setItem(KEY_CHAIN, JSON.stringify(chain));
}

async function addRecord(data) {
  const chain = getChain();
  const prevHash = chain.length ? chain[chain.length-1].hash : 'genesis';
  const block = {
    index: chain.length,
    time: Date.now(),
    prevHash,
    data,
    hash: ''
  };
  block.hash = await sha256(JSON.stringify(block));
  chain.push(block);
  saveChain(chain);
  return block;
}

// æ ¡éªŒæ•´æ¡é“¾æ˜¯å¦è¢«ç¯¡æ”¹
async function verifyChain() {
  const chain = getChain();
  for (let i = 1; i < chain.length; i++) {
    const cur = chain[i];
    const pre = chain[i-1];
    const tempBlock = { ...cur, hash: '' };
    const reHash = await sha256(JSON.stringify(tempBlock));
    if (cur.hash !== reHash || cur.prevHash !== pre.hash) {
      return false;
    }
  }
  return true;
}

// æŒ‰é’®è°ƒç”¨æ ¡éªŒ
async function verifyChainBtn() {
  const ok = await verifyChain();
  if (ok) {
    log('âœ… æ ¡éªŒé€šè¿‡ï¼šæ•°æ®æœªè¢«ç¯¡æ”¹ï¼Œé“¾æœ‰æ•ˆ');
  } else {
    log('âŒ æ ¡éªŒå¤±è´¥ï¼šæ•°æ®å·²è¢«ç¯¡æ”¹ï¼');
  }
}

// ====================== é“å…·ç³»ç»Ÿ ======================
async function mintItem() {
  const mne = localStorage.getItem(KEY_MNEMONIC);
  if (!mne) return log('âš ï¸ å…ˆåˆ›å»ºé’±åŒ…');
  const block = await addRecord({
    type: 'item',
    owner: mne,
    name: 'æ–°æ‰‹å‰‘',
    id: Date.now()
  });
  log(`âœ… è·å¾—ã€æ–°æ‰‹å‰‘ã€‘ åŒºå—#${block.index}`);
}

function showItems() {
  const mne = localStorage.getItem(KEY_MNEMONIC);
  if (!mne) return log('âš ï¸ æœªåˆ›å»ºé’±åŒ…');
  const items = getChain().filter(b => b.data.type === 'item' && b.data.owner === mne);
  log(`ğŸ’ é“å…·æ•°é‡ï¼š${items.length}`);
}

// ====================== å¯¼å‡º/å¯¼å…¥å­˜æ¡£ ======================
function exportArchive() {
  const data = {
    mnemonic: localStorage.getItem(KEY_MNEMONIC),
    chain: getChain()
  };
  const blob = new Blob([JSON.stringify(data)], {type: 'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'game-archive.json';
  a.click();
  URL.revokeObjectURL(url);
  log('ğŸ“¤ å­˜æ¡£å·²å¯¼å‡º');
}

function importArchive() {
  const input = document.createElement('input');
  input.type = 'file';
  input.accept = '.json';
  input.onchange = e => {
    const file = e.target.files[0];
    if (!file) return;
    const fr = new FileReader();
    fr.onload = ev => {
      try {
        const data = JSON.parse(ev.target.result);
        if (data.mnemonic && data.chain) {
          localStorage.setItem(KEY_MNEMONIC, data.mnemonic);
          saveChain(data.chain);
          log('ğŸ“¥ å¯¼å…¥æˆåŠŸï¼');
          showItems();
        } else {
          log('âŒ å­˜æ¡£æ ¼å¼é”™è¯¯');
        }
      } catch (e) {
        log('âŒ å¯¼å…¥å¤±è´¥');
      }
    };
    fr.readAsText(file);
  };
  input.click();
}

window.onload = initChain;
</script>
</body>
</html>
